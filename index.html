<script>
/* ================= CONFIG ================= */
const COUNT = 1500;
const SHAPES = ['Sphere','Heart','Flower','Saturn','Fireworks'];
let shapeIndex = 0;
let currentShape = SHAPES[0];
let cooldown = false;

let hand = new THREE.Vector3();
let pinch = 1;

/* ================= THREE ================= */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505,0.03);

const camera = new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,500);
camera.position.z = 25;

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(devicePixelRatio);
document.body.appendChild(renderer.domElement);

const geo = new THREE.BufferGeometry();
const pos = new Float32Array(COUNT*3);
const target = new Float32Array(COUNT*3);
const col = new Float32Array(COUNT*3);

for(let i=0;i<COUNT;i++){
  pos[i*3]=(Math.random()-.5)*40;
  pos[i*3+1]=(Math.random()-.5)*40;
  pos[i*3+2]=(Math.random()-.5)*40;
  col[i*3]=0;
  col[i*3+1]=1;
  col[i*3+2]=1;
}

geo.setAttribute('position',new THREE.BufferAttribute(pos,3));
geo.setAttribute('color',new THREE.BufferAttribute(col,3));

const mat = new THREE.PointsMaterial({
  size:0.15,
  vertexColors:true,
  transparent:true,
  opacity:0.85
});

const points = new THREE.Points(geo,mat);
scene.add(points);

/* ================= SHAPES ================= */
function setShape(name){
  currentShape = name;
  document.getElementById('shape').textContent = name;

  for(let i=0;i<COUNT;i++){
    let x,y,z;

    const t = i/COUNT * Math.PI*2;
    const r = Math.sqrt(Math.random());

    if(name==='Sphere'){
      const a=Math.random()*Math.PI*2;
      const b=Math.acos(2*Math.random()-1);
      x=8*Math.sin(b)*Math.cos(a);
      y=8*Math.sin(b)*Math.sin(a);
      z=8*Math.cos(b);
    }

    if(name==='Heart'){
      x=16*Math.pow(Math.sin(t),3)*0.5;
      y=(13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t))*0.4;
      z=(Math.random()-.5)*3;
    }

    if(name==='Flower'){
      x=10*Math.cos(t)*Math.sin(5*t);
      y=10*Math.sin(t)*Math.sin(5*t);
      z=(Math.random()-.5)*3;
    }

    if(name==='Saturn'){
      const ring = i%2;
      const rr = ring?10:5;
      x=Math.cos(t)*rr;
      y=Math.sin(t)*rr;
      z=ring?(Math.random()-.5):0;
    }

    if(name==='Fireworks'){
      const a=Math.random()*Math.PI*2;
      const b=Math.random()*Math.PI;
      const rr=Math.random()*10;
      x=Math.sin(b)*Math.cos(a)*rr;
      y=Math.sin(b)*Math.sin(a)*rr;
      z=Math.cos(b)*rr;
    }

    target[i*3]=x;
    target[i*3+1]=y;
    target[i*3+2]=z;
  }
}
setShape(currentShape);

/* ================= HAND TRACKING ================= */
const video = document.getElementById('input-video');
const hands = new Hands({
  locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({
  maxNumHands:1,
  modelComplexity:1,
  minDetectionConfidence:0.7,
  minTrackingConfidence:0.7
});

hands.onResults(res=>{
  if(!res.multiHandLandmarks) return;
  const lm = res.multiHandLandmarks[0];

  const ix = lm[8];
  const th = lm[4];

  hand.x=(ix.x-0.5)*30;
  hand.y=-(ix.y-0.5)*20;
  hand.z=0;

  pinch = Math.hypot(ix.x-th.x, ix.y-th.y);

  const fist =
    lm[8].y>lm[6].y &&
    lm[12].y>lm[10].y &&
    lm[16].y>lm[14].y &&
    lm[20].y>lm[18].y;

  if(fist && !cooldown){
    shapeIndex=(shapeIndex+1)%SHAPES.length;
    setShape(SHAPES[shapeIndex]);
    cooldown=true;
    setTimeout(()=>cooldown=false,800);
  }
});

new Camera(video,{
  onFrame:async()=>await hands.send({image:video}),
  width:640,
  height:480
}).start();

/* ================= ANIMATE ================= */
function animate(){
  requestAnimationFrame(animate);
  const p=geo.attributes.position.array;

  for(let i=0;i<COUNT;i++){
    const ix=i*3;
    p[ix]+= (target[ix]+hand.x-p[ix])*0.02*(1/pinch);
    p[ix+1]+= (target[ix+1]+hand.y-p[ix+1])*0.02*(1/pinch);
    p[ix+2]+= (target[ix+2]-p[ix+2])*0.02;
  }
  geo.attributes.position.needsUpdate=true;
  scene.rotation.y+=0.001;
  renderer.render(scene,camera);
}
animate();

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>